import _ from 'underscore'

import { generateHmac } from 'src/modules/game/lib/provably_fair/sharedAlgorithms'

/**
 * @param groupSize e.g. number of cards in a deck
 * @param hash generated by the caller
 */
export function buildGroup(groupSize: number, hash: string): number[] {
  let randomNumbers: number[] = []
  let shuffleNonce = 0

  do {
    const newHash = generateHmac(hash, shuffleNonce.toString())
    const tempArr = seedToBytes(newHash)
    const randomArr = randomNumbers.concat(
      bytesToNumbers(tempArr, newHash.length * 4),
    )
    randomNumbers = randomArr
    shuffleNonce += 1
  } while (randomNumbers.length < groupSize)

  if (randomNumbers.length > groupSize) {
    randomNumbers = randomNumbers.slice(0, groupSize)
  }

  const shuffled = shuffleGroup(randomNumbers, groupSize)
  return shuffled
}

/**
 * Returns an array of 0s and 1s (effectively a boolean array)
 * @param numberCount e.g. number of booleans to return
 * @param hash generated by the caller
 */
export function buildRandomBools(numberCount: number, hash: string): number[] {
  let randomNumbers: number[] = []
  let shuffleNonce = 0

  do {
    const newHash = generateHmac(hash, shuffleNonce.toString())
    const tempArr = seedToBytes(newHash)
    const randomArr = randomNumbers.concat(
      bytesToNumbers(tempArr, newHash.length * 4),
    )
    randomNumbers = randomArr
    shuffleNonce += 1
  } while (randomNumbers.length < numberCount)

  if (randomNumbers.length > numberCount) {
    randomNumbers = randomNumbers.slice(0, numberCount)
  }

  const result = randomNumbers.map(num => Math.floor(num * 2))
  return result
}

/**
 * @param hash a SHA256 or SHA512 hash as the seed
 */
export function seedToBytes(hash: string) {
  const chunkierBoy = _.chunk(hash.split(''), 2).map(bytePair => {
    const twoBytes = bytePair.join('')
    return parseInt(twoBytes, 16)
  })
  return chunkierBoy
}

/**
 * Expects an array of bytes from seedToBytes function and either 256 or 512
 * for the hashLength (character length of either SHA256 or SHA512 hash).
 */
export function bytesToNumbers(byteArr: number[], hashLength: number) {
  const chunkyBoy = _.chunk(byteArr, 4).map(numArr => {
    const numA = numArr[0] / Math.pow(hashLength, 1)
    const numB = numArr[1] / Math.pow(hashLength, 2)
    const numC = numArr[2] / Math.pow(hashLength, 3)
    const numD = numArr[3] / Math.pow(hashLength, 4)
    return numA + numB + numC + numD
  })
  return chunkyBoy
}

/**
 * Utilizes the Fisher-Yates-Durstenfeld shuffle algorithm, but we generate
 * a random number using the functions above instead of something like
 * Math.rand(). This ensures provably fair.
 */
export function shuffleGroup(randomNumbers: number[], groupSize: number) {
  const shuffledNumbers = _.range(groupSize)

  let randIndex = 0
  for (let i = groupSize - 1; i > 0; i--) {
    const j = Math.floor(randomNumbers[randIndex] * (i + 1))

    const tmp = shuffledNumbers[j]
    shuffledNumbers[j] = shuffledNumbers[i]
    shuffledNumbers[i] = tmp
    randIndex += 1
  }
  return shuffledNumbers
}
