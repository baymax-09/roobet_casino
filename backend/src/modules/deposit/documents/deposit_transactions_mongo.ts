import {
  type FilterQuery,
  type ClientSession,
  type SortOrder,
  type Types,
} from 'mongoose'

import { megaloMongo } from 'src/system'
import { schema as CashDepositTransactionsSchema } from 'src/vendors/paymentiq/documents/cash_deposit_transactions'
import { type DBCollectionSchema } from 'src/modules'
import { type Currency } from 'src/modules/currency/types'
import { type DepositInfo } from 'src/vendors/fasttrack/types'
import {
  FASTTRACK_DEPOSIT_FIELDS,
  validFastTrackUpdateField,
  publishUserDepositMessageToFastTrack,
} from 'src/vendors/fasttrack'
import { mongoChangeFeedHandler } from 'src/util/mongo'
import { type CryptoNetwork } from 'src/modules/crypto/types'

import { DepositStatuses } from '../lib/util'
import {
  type BaseDeposit,
  type DepositMeta,
  type CryptoDepositType,
  type DepositStatus,
} from '../types'
import { depositLogger } from '../lib/logger'

export interface Deposit extends BaseDeposit {
  _id: Types.ObjectId
  createdAt: Date
  updatedAt: Date
}

interface BaseDepositPayload {
  userId: string
  depositType: CryptoDepositType
  network: CryptoNetwork
  amount: number
  currency: Currency
  confirmations: number
  /** Should be a unique ID derived from the wallet address and transactionHash */
  id: string

  status?: DepositStatus
  externalId?: string
  meta?: DepositMeta
}

interface PaginatedDepositArgs {
  userId: string
  limit?: number
  sort?: Record<string, 1 | -1> | undefined
  page?: number
  startDate?: string
  endDate?: string
  filter?: FilterQuery<Deposit>
}

const DepositTransactionsMongoSchema = new megaloMongo.Schema<Deposit>(
  {
    id: { type: String, unique: true, index: true }, // depositId generated by processes external to this model
    userId: { type: String, index: true },
    confirmations: { type: Number, default: 0 },
    depositType: { type: String },
    network: { type: String },
    amount: { type: Number },
    currency: { type: String },
    externalId: { type: String },
    status: {
      type: String,
      index: true,
      default: DepositStatuses.Initiated,
    },
    tracked: { type: Boolean },
    reason: { type: String },

    meta: {},
    secrets: {},
  },
  // We do not want strict: false in more collections, don't follow this pattern.
  { strict: false, timestamps: true },
)

DepositTransactionsMongoSchema.index({ depositType: 1, status: 1 })
DepositTransactionsMongoSchema.index({ userId: 1, depositType: 1, status: 1 })
DepositTransactionsMongoSchema.index({ userId: 1, createdAt: 1, status: 1 })

export const DepositTransactionsMongo = megaloMongo.model<Deposit>(
  'deposit_transactions_mongo',
  DepositTransactionsMongoSchema,
)

/** Do not use this function outside of the Deposit module */
export async function createDepositTransaction(
  payload: BaseDepositPayload,
): Promise<Deposit> {
  return (await DepositTransactionsMongo.create(payload)).toObject<Deposit>()
}

export async function updateDepositTransactionStatus(
  _id: Types.ObjectId,
  status: DepositStatus,
): Promise<{ mutated: boolean; deposit: Deposit | null }> {
  const result = await DepositTransactionsMongo.findOneAndUpdate(
    { _id },
    { status },
    {
      includeResultMetadata: true,
    },
  )

  const mutated = !!result.value && result.value.status !== status

  // Fetch the updated deposit separate from updating the record.
  const deposit = await DepositTransactionsMongo.findById(_id)

  return {
    mutated,
    deposit,
  }
}

const updateDepositTransactionWithChecks = async (
  filter: Partial<Deposit>,
  payload: Partial<Omit<Deposit, '_id'>>,
  session?: ClientSession,
): Promise<Deposit | null> => {
  const confirmations = payload.confirmations ?? 0

  const updatePayload = [
    {
      $set: {
        ...payload,
        confirmations: {
          $cond: [
            { $lt: ['$confirmations', confirmations] },
            confirmations,
            '$confirmations',
          ],
        },
      },
    },
  ]

  return await DepositTransactionsMongo.findOneAndUpdate(
    filter,
    updatePayload,
    { session },
  ).lean()
}

export async function updateDepositTransaction(
  payload: Partial<Omit<Deposit, 'id'>>,
  session?: ClientSession,
): Promise<Deposit | null> {
  const { _id, ...updates } = payload

  return await updateDepositTransactionWithChecks({ _id }, updates, session)
}

export async function updateDepositTransactionById(
  payload: Partial<Omit<Deposit, '_id'>>,
  session?: ClientSession,
): Promise<Deposit | null> {
  const { id, ...updates } = payload

  return await updateDepositTransactionWithChecks({ id }, updates, session)
}

export async function getDepositTransactionByDepositId(
  id: string,
): Promise<Deposit | null> {
  return await DepositTransactionsMongo.findOne({ id }).lean()
}

export async function getPendingTransactionsOfType(
  types: CryptoDepositType[],
): Promise<Deposit[]> {
  return await DepositTransactionsMongo.find({
    depositType: { $in: types },
    status: DepositStatuses.Pending,
  }).lean()
}

export async function cancelDepositTransaction(
  _id: Types.ObjectId,
  reason: string,
): Promise<Deposit | null> {
  const payload = { _id, status: DepositStatuses.Cancelled, reason }
  return await updateDepositTransaction(payload)
}

export const getFirstCompletedDeposit = async (
  userId: string,
): Promise<Deposit | undefined> => {
  return (
    await DepositTransactionsMongo.find({ userId, status: 'completed' })
      .sort({ createdAt: 1 })
      .limit(1)
      .lean()
  )[0]
}

export async function countUnconfirmedTransactionsByUserId(
  userId: string,
): Promise<number> {
  const unconfirmedDocs = await DepositTransactionsMongo.aggregate([
    {
      $match: { userId, status: DepositStatuses.Completed },
    },
    {
      $match: {
        $or: [
          {
            depositType: 'bitcoin',
            confirmations: 0,
          },
          {
            depositType: 'litecoin',
            confirmations: 0,
          },
          {
            depositType: 'dogecoin',
            confirmations: 0,
          },
          {
            depositType: 'ethereum',
            confirmations: {
              $lt: 3,
            },
          },
        ],
      },
    },
    {
      $count: 'count',
    },
  ])

  return unconfirmedDocs[0]?.count ?? 0
}

export async function countUserDepositsInTimePeriod(
  userId: string,
  startDate: Date,
  endDate: Date,
): Promise<number> {
  return await DepositTransactionsMongo.find({
    userId,
    status: DepositStatuses.Completed,
    createdAt: { $gte: startDate, $lte: endDate },
  }).countDocuments()
}

export async function sumDepositsInTimePeriod(
  userId: string,
  startDate: Date,
  endDate: Date,
): Promise<number> {
  const sumDoc = await DepositTransactionsMongo.aggregate([
    {
      $match: {
        userId,
        status: DepositStatuses.Completed,
        createdAt: { $gte: startDate, $lte: endDate },
      },
    },
    {
      $group: {
        _id: null,
        totalDepositAmount: {
          $sum: '$amount',
        },
      },
    },
  ])

  return sumDoc[0]?.totalDepositAmount ?? 0
}

export const getPaginatedDeposits = async ({
  userId,
  limit = 25,
  page = 0,
  sort = { createdAt: -1 },
  startDate,
  endDate,
  filter,
}: PaginatedDepositArgs) => {
  const payload: FilterQuery<Deposit> = {
    ...filter,
    userId,
  }

  if (startDate && endDate) {
    payload.createdAt = {
      $gte: new Date(startDate),
      $lte: new Date(endDate),
    }
  }

  const pipeline = [
    { $match: payload },
    {
      $unionWith: {
        coll: CashDepositTransactionsSchema.name,
        pipeline: [{ $match: payload }],
      },
    },
  ]

  // I know this looks bad, Mongo recommends using $facet but there are known efficiency problems with large data sets
  const [data, count] = await Promise.all([
    DepositTransactionsMongo.aggregate([
      ...pipeline,
      { $sort: sort },
      { $skip: page * limit },
      { $limit: limit },
    ]).exec(),
    DepositTransactionsMongo.aggregate([
      ...pipeline,
      { $count: 'count' },
    ]).exec(),
  ])

  return { data, count: count?.[0]?.count ?? 0, page, limit }
}

/** @deprecated Use getPaginatedDeposits instead. */
export async function tableSearchDeposits(
  limit = 25,
  page = 0,
  sortObj: Record<string, SortOrder> = { timestamp: -1 },
  filterObj = {},
) {
  const query = () => DepositTransactionsMongo.find(filterObj).sort(sortObj)

  return {
    page,
    limit,
    count: await query().countDocuments(),
    data: await query()
      .limit(limit)
      .skip(page * limit),
  }
}

/* FEEDS */
export const depositsChangeFeed = async () => {
  const logger = depositLogger('depositsChangeFeed', { userId: null })
  try {
    await mongoChangeFeedHandler<Deposit>(
      DepositTransactionsMongo,
      async document => {
        if (
          document.fullDocument &&
          validFastTrackUpdateField(document, FASTTRACK_DEPOSIT_FIELDS)
        ) {
          const { _id, currency, status, amount, userId } =
            document.fullDocument
          const deposit: DepositInfo = {
            currency,
            status,
            amount,
            paymentId: _id,
            userId,
            vendorId: 'inhouse',
          }
          logger.info(
            `publishing message for events.userDeposit crypto - ${deposit}`,
            { deposit },
          )
          publishUserDepositMessageToFastTrack({
            deposit,
          })
        }
      },
    )
  } catch (error) {
    logger.error(
      `There was an error in the deposits change feed - ${error.message}`,
      {},
      error,
    )
  }
}

export const schema: DBCollectionSchema = {
  db: 'megalomongo',
  name: 'deposit_transactions_mongo',
  feeds: [depositsChangeFeed],
}
